/* 10 */
class W {
	static cc = () => document.createElement('canvas');
	static compess(u8a) {
		const b = u8a.length,
			s = Math.ceil(Math.sqrt(Math.ceil(b / 3) + 2)),
			c = W.cc();
		c.width = c.height = s;
		const x = c.getContext('2d'),
			d = x.createImageData(s, s),
			l = d.data.length,
			n = new Uint8Array(l);
		n.fill(255);
		n[l - 3] = b % 256;
		n[l - 2] = b >>> 8;
		for (let i = 0, j = 0; j < b; i++) if (i % 4 !== 3) n[i] = u8a[j++];
		for (let i = 0; i < l; i++) d.data[i] = n[i];
		x.putImageData(d, 0, 0);
		return c.toDataURL('image/png');
	}
	static dc4DURI(dURI) {
		return new Promise((r) => {
			const i = new Image();
			i.onload = () => {
				const s = i.width,
					l = s * s * 4,
					c = W.cc();
				c.width = c.height = s;
				const x = c.getContext('2d');
				x.drawImage(i, 0, 0);
				const d = x.getImageData(0, 0, s, s),
					n = d.data,
					b = (n[l - 2] << 8) + n[l - 3],
					u = new Uint8Array(b);
				for (let j = 0, k = 0; k < b; j++) if (j % 4 !== 3) u[k++] = n[j];
				r(u);
			};
			i.src = dURI;
		});
	}
	static td = new TextDecoder('utf-8');
	static v =
		'{"a":"infoBits","b":"versionNumber","c":"alignmentPatternCenters","d":"errorCorrectionLevels","e":"ecCodewordsPerBlock","f":"ecBlocks","g":"numBlocks","h":"dataCodewordsPerBlock"}';
	static d =
		'data:image/png;base64,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';
	degree;
	static vc(obj, km, keys) {
		if (Array.isArray(obj)) for (const r of obj) W.vc(r, km, keys);
		else if (typeof obj === 'object')
			for (const k in obj) {
				const v = obj[k];
				delete obj[k];
				obj[F.getK(k, km, keys)] = v;
				W.vc(v, km, keys);
			}
	}
	static gK = (k, km, keys) => (km[k] ? km[k] : (km[k] = keys[Object.keys(km).length]));
	static p = [
		['"', ''],
		[':', ''],
		['},{', '='],
		['[{', '<'],
		['}]', '>'],
		['>>=', '#'],
		['>=', '%'],
	];
	static ej(json, p = W.p) {
		let a = json;
		for (const q of p) a = q[0] ? a.split(q[0]).join(q[1]) : a;
		return a;
	}
	static dj(j, vm) {
		let p = JSON.parse(JSON.stringify(W.p));
		for (const r of p) r.reverse();
		p.reverse();
		let a = W.ej(j, p);
		for (const k in vm) a = a.split(k).join(`"${k}":`);
		return a;
	}
	static rm(km) {
		const vm = {};
		for (const [k, v] of Object.entries(km)) vm[v] = k;
		return vm;
	}
	static vd(obj, vm) {
		if (Array.isArray(obj)) for (const r of obj) W.vd(r, vm);
		else if (typeof obj === 'object') {
			for (const k in obj) {
				const v = obj[k];
				delete obj[k];
				obj[vm[k]] = v;
				W.vd(v, vm);
			}
		}
	}
	static ab2S = (ab) => W.td.decode(new Uint8Array(ab));
	static keys = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
	static async gV() {
		const u = await W.dc4DURI(W.d),
			v = JSON.parse(W.v),
			m = JSON.parse(W.dj(W.ab2S(u.buffer), v));
		W.vd(m, v);
		return m;
	}
	static compress(t) {
		const k = Object.keys(t),
			u = new Uint8Array(k.length * 4);
		let c = 0;
		u.fill(0);
		for (const [k, v] of Object.entries(t)) {
			const n = k * 1;
			u[c + 0] = n >> 8;
			u[c + 1] = n % 256;
			u[c + 2] = v >> 8;
			u[c + 3] = v % 256;
			c += 4;
		}
		return u;
	}
	static dp(a) {
		const m = {},
			l = a.length;
		for (let c = 0; c < l; c += 4) m[((a[c + 0] << 8) | a[c + 1]) + ''] = (a[c + 2] << 8) | a[c + 3];
		return m;
	}
	static SJIS_dURI =
		'data:image/png;base64,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';

	static gST = async () => W.dp(await W.dc4DURI(W.SJIS_dURI));
	static VERSIONS = null;
	static shiftJISTable = null;
	static async init() {
		if (W.VERSIONS && W.shiftJISTable) return;
		W.VERSIONS = await W.gV();
		/* 8 */
		W.shiftJISTable = await W.gST();
	}
	static u8ca = (s) => new Uint8ClampedArray(s);
	static e(m) {
		throw new Error(m);
	}
	static cat = (b, a) => Array.prototype.push.apply(b, a);
	static A = (s) => new Array(s);
	static n = (m, n, l) => (console.log(m, n, l) ? null : null);
}
/*0 BitMatrix*/
class BM {
	constructor(d, w) {
		this.width = w;
		this.height = d.length / w;
		this.data = d;
	}
	static c = (w, h) => new BM(W.u8ca(w * h), w); //createEmpty //width,height
	get(x, y) {
		return x < 0 || x >= this.width || y < 0 || y >= this.height ? false : !!this.data[y * this.width + x];
	}
	set(x, y, v) {
		this.data[y * this.width + x] = v ? 1 : 0;
	}
	sR(l, t, w, h, v) {
		for (let y = t; y < t + h; y++) for (let x = l; x < l + w; x++) this.set(x, y, !!v); //setRegion //left, top,width,height
	}
}
/* 1 GenericGF*/
class GF {
	static a = (a, b) => a ^ b; // addOrSubtractGF
	constructor(p, s, g) {
		const z = this; //primitive, size, genBase
		z.p = p; //primitive
		z.s = s; //size
		z.g = g; //generatorBase
		z.E = W.A(z.s); //expTable
		z.L = W.A(z.s); //logTable
		let x = 1;
		for (let i = 0; i < z.s; i++) {
			z.E[i] = x;
			x = x * 2;
			if (x >= z.s) x = (x ^ z.p) & (z.s - 1);
		}
		for (let i = 0; i < z.s - 1; i++) z.L[z.E[i]] = i;
		z.zero = new GP(z, Uint8ClampedArray.from([0]));
		z.one = new GP(z, Uint8ClampedArray.from([1]));
	}
	m(a, b) {
		return a === 0 || b === 0 ? 0 : this.E[(this.L[a] + this.L[b]) % (this.s - 1)];
	}
	i(a) {
		if (a === 0) W.e("Can't invert 0"); //inverse
		return this.E[this.s - this.L[a] - 1];
	}
	b(d, c) {
		if (d < 0) W.e('Invalid monomial degree less than 0'); //buildMonomial//deg, coefficient
		if (c === 0) return this.zero;
		const e = W.u8ca(d + 1); //coefficients
		e[0] = c;
		return new GP(this, e);
	}
	l(a) {
		if (a === 0) W.e("Can't take log(0)"); //log
		return this.l[a];
	}
	e(a) {
		return this.E[a];
	}
}
/* 2 GenericGFPoly*/
class GP {
	constructor(f, c) {
		if (c.length === 0) W.e('No coefficients.'); //field, coefficients
		const z = this;
		z.F = f;
		const cl = c.length; //coefficientsLength
		if (cl > 1 && c[0] === 0) {
			let f = 1; //firstNonZero // Leading term must be non-zero for anything except the constant polynomial "0"
			while (f < cl && c[f] === 0) f++;
			if (f === cl) z.C = f.zero.C;
			else {
				z.C = W.u8ca(cl - f);
				for (let i = 0; i < z.C.length; i++) z.C[i] = c[f + i];
			}
		} else z.C = c;
	}
	d() {
		return this.C.length - 1; //degree
	}
	z() {
		return this.C[0] === 0; //isZero
	}
	c(d) {
		return this.C[this.C.length - 1 - d]; //getCoefficient(deg)
	}
	a(o) {
		const z = this; //addOrSubtract//other
		if (z.z()) return o;
		if (o.z()) return z;
		let sc = z.C, //smallerCoefficients
			lc = o.C; //largerCoefficients
		const j = [lc, sc];
		if (sc.length > lc.length) (sc = j[0]), (lc = j[1]);
		const sd = W.u8ca(lc.length), //sumDiff
			ld = lc.length - sc.length; //lengthDiff
		for (let i = 0; i < ld; i++) sd[i] = lc[i];
		for (let i = ld; i < lc.length; i++) sd[i] = GF.a(sc[i - ld], lc[i]);
		return new GP(z.F, sd);
	}
	m(s) {
		const z = this; //multiply//scalar
		if (s === 0) return z.F.zero;
		if (s === 1) return z;
		const e = z.C.length, //size
			p = W.u8ca(e); //product
		for (let i = 0; i < e; i++) p[i] = z.F.m(z.C[i], s);
		return new GP(z.F, p);
	}
	p(o) {
		const z = this; //multiplyPoly //other
		if (z.z() || o.z()) return z.F.zero;
		const ac = z.C, //aCoefficients
			al = ac.length, //aLength
			bc = o.C, //bCoefficients
			bl = bc.length, //bLength
			p = W.u8ca(al + bl - 1); //product
		for (let i = 0; i < al; i++) {
			const a = ac[i];
			for (let j = 0; j < bl; j++) p[i + j] = GF.a(p[i + j], z.F.m(a, bc[j]));
		}
		return new GP(z.F, p);
	}
	b(d, c) {
		if (d < 0) W.e('Invalid degree less than 0'); //multiplyByMonomial//deg, coefficient
		if (c === 0) return this.F.zero;
		const s = this.C.length, //size
			p = W.u8ca(s + d); //product
		for (let i = 0; i < s; i++) p[i] = this.F.m(this.C[i], c);
		return new GP(this.F, p);
	}
	e(a) {
		const z = this;
		if (a === 0) return z.c(0); // Just return the x^0 coefficient
		const s = z.C.length; //size
		let r = 0; //result
		if (a === 1) {
			z.C.forEach((c) => {
				r = GF.a(r, c);
			}); //coefficient // Just the sum of the coefficients
			return r;
		}
		r = z.C[0];
		for (let i = 1; i < s; i++) r = GF.a(z.F.m(a, r), z.C[i]);
		return r;
	}
}
/* 9 Reedsolomon*/
class RS {
	static rEA(f, a, b, R) {
		const i = [b, a]; //runEuclideanAlgo//field, a, b, R
		if (a.d() < b.d()) (a = i[0]), (b = i[1]); // Assume a's degree is >= b's
		let rL = a, //rLast
			r = b,
			tL = f.zero, //tLast
			t = f.one;
		while (r.d() >= R / 2) {
			const rLL = rL, //rLastLast // Run Euclidean algorithm until r's degree is less than R/2
				tLL = tL; //tLastLast
			rL = r;
			tL = t; // Divide rLastLast by rLast, with quotient in q and remainder in r
			if (rL.z()) return null; // Euclidean algorithm already terminated?
			r = rLL;
			let q = f.zero;
			const dLT = rL.c(rL.d()), //denominatorLeadingTerm
				dI = f.i(dLT); //dltInverse
			while (r.d() >= rL.d() && !r.z()) {
				const dD = r.d() - rL.d(), //degreeDiff
					s = f.m(r.c(r.d()), dI); //scale
				q = q.a(f.b(dD, s));
				r = r.a(rL.b(dD, s));
			}
			t = q.p(tL).a(tLL);
			if (r.d() >= rL.d()) return null;
		}
		const sT = t.c(0); //sigmaTildeAtZero
		if (sT === 0) return null;
		const iv = f.i(sT); //inverse
		return [t.m(iv), r.m(iv)];
	}
	static fEL(f, eL) {
		const nE = eL.d(); //findErrorLocations // field, errLocator//numErrors// This is a direct application of Chien's searchS
		if (nE === 1) return [eL.c(1)];
		const r = W.A(nE);
		let eC = 0; //errorCount
		for (let i = 1; i < f.s && eC < nE; i++)
			if (eL.e(i) === 0) {
				r[eC] = f.i(i);
				eC++;
			}
		return eC !== nE ? null : r;
	}
	static fEM(f, eE, eL) {
		const s = eL.length; //findErrorMagnitudes //field, errEvaluator, errLocations // This is directly applying Forney's Formula
		const r = W.A(s);
		for (let i = 0; i < s; i++) {
			const xi = f.i(eL[i]); //xiInverse
			let d = 1; //denominator
			for (let j = 0; j < s; j++) if (i !== j) d = f.m(d, GF.a(1, f.m(eL[j], xi)));
			r[i] = f.m(eE.e(xi), f.i(d));
			if (f.g !== 0) r[i] = f.m(r[i], xi);
		}
		return r;
	}
	static dec(b, s2) {
		const oB = W.u8ca(b.length); //decode//bytes, twoS//outputBytes
		oB.set(b);
		const f = new GF(0x011d, 256, 0), //field// x^8 + x^4 + x^3 + x^2 + 1
			p = new GP(f, oB), //poly
			sC = W.u8ca(s2); //syndromeCoefficients
		let e = false; //error
		for (let s = 0; s < s2; s++) {
			e = p.e(f.e(s + f.g)); //evaluation
			sC[sC.length - 1 - s] = e;
			if (e !== 0) e = true;
		}
		if (!e) return oB;
		const sy = new GP(f, sC), //syndrome
			sO = RS.rEA(f, f.b(s2, 1), sy, s2); //sigmaOmega
		if (sO === null) return null;
		const eL = RS.fEL(f, sO[0]); //errorLocations
		if (eL == null) return null;
		const eM = RS.fEM(f, sO[1], eL); //errorMagnitudes
		for (let i = 0; i < eL.length; i++) {
			const po = oB.length - 1 - f.l(eL[i]); //position
			if (po < 0) return null;
			oB[po] = GF.a(oB[po], eM[i]);
		}
		return oB;
	}
}
/* 4 Matrix // Like BitMatrix but accepts arbitry Uint8 values*/
class Mtx {
	constructor(w, h) {
		this.width = w;
		this.data = W.u8ca(w * h);
	}
	get(x, y) {
		return this.data[y * this.width + x];
	}
	set(x, y, v) {
		this.data[y * this.width + x] = v;
	}
}
class BZ {
	static R = 8; //REGION_SIZE
	static M = 24; //MIN_DYNAMIC_RANGE
	static nb = (v, i, x) => (v < i ? i : v > x ? x : v); //numBetween(value, min, max)
	static bz(d, w, h, r) {
		if (d.length !== w * h * 4) W.e('Malformed data passed to binarizer.'); //binarize //data, w, h, returnInverted
		const gP = new Mtx(w, h); //greyscalePixels // Convert image to greyscale
		for (let x = 0; x < w; x++)
			for (let y = 0; y < h; y++) {
				const p = (y * w + x) * 4,
					r = d[p + 0],
					g = d[p + 1],
					b = d[p + 2];
				gP.set(x, y, 0.2126 * r + 0.7152 * g + 0.0722 * b);
			}
		const RS = BZ.R,
			M = Math,
			hRC = M.ceil(w / RS), //horizontalRegionCount
			vRC = M.ceil(h / RS), //verticalRegionCount
			bP = new Mtx(hRC, vRC); //blackPoints
		for (let vR = 0; vR < vRC; vR++) {
			for (let hR = 0; hR < hRC; hR++) {
				let sum = 0,
					min = Infinity,
					max = 0;
				for (let y = 0; y < RS; y++)
					for (let x = 0; x < RS; x++) {
						let pL = gP.get(hR * RS + x, vR * RS + y); //pixelLumosity
						sum += pL;
						min = M.min(min, pL);
						max = M.max(max, pL);
					}
				let avg = sum / M.pow(RS, 2);
				if (max - min <= BZ.M) {
					// If variation within the block is low, assume this is a block with only light or only
					// dark pixels. In that case we do not want to use the average, as it would divide this
					// low contrast area into black and white pixels, essentially creating data out of noise.
					//
					// Default the blackpoint for these blocks to be half the min - effectively white them out
					avg = min / 2;
					if (vR > 0 && hR > 0) {
						// Correct the "white background" assumption for blocks that have neighbors by comparing
						// the pixels in this block to the previously calculated black points. This is based on
						// the fact that dark barcode symbology is always surrounded by some amount of light
						// background for which reasonable black point estimates were made. The bp estimated at
						// the boundaries is used for the interior.
						// The (min < bp) is arbitrary but works better than other heuristics that were tried.
						const aNBP = (bP.get(hR, vR - 1) + 2 * bP.get(hR - 1, vR) + bP.get(hR - 1, vR - 1)) / 4; //averageNeighborBlackPoint
						if (min < aNBP) avg = aNBP;
					}
				}
				bP.set(hR, vR, avg);
			}
		}
		const bz = BM.c(w, h), //binarized
			iv = r ? BM.c(w, h) : null; //inverted
		for (let vR = 0; vR < vRC; vR++)
			for (let hR = 0; hR < hRC; hR++) {
				const l = BZ.nb(hR, 2, hRC - 3), //left
					t = BZ.nb(vR, 2, vRC - 3); //top_1
				let sum = 0;
				for (let xR = -2; xR <= 2; xR++) for (let yR = -2; yR <= 2; yR++) sum += bP.get(l + xR, t + yR);
				const th = sum / 25; //threshold
				for (let xR = 0; xR < RS; xR++)
					for (let yR = 0; yR < RS; yR++) {
						const x = hR * RS + xR,
							y = vR * RS + yR,
							lum = gP.get(x, y);
						bz.set(x, y, lum <= th);
						if (r) iv.set(x, y, !(lum <= th));
					}
			}
		return r ? { binarized: bz, inverted: iv } : { binarized: bz };
	}
}
/* 7 BitStream*/
class BS {
	constructor(b) {
		this.byteOffset = 0;
		this.bitOffset = 0;
		this.bytes = b;
	}
	r(nB) {
		const z = this; //readBits
		if (nB < 1 || nB > 32 || nB > z.a()) W.e('Cannot read ' + nB.toString() + ' bits'); //numBits
		let r = 0;
		if (z.bitOffset > 0) {
			const bL = 8 - z.bitOffset, //bitsLeft// First, read remainder from current byte
				tR = nB < bL ? nB : bL, //toRead
				bN = bL - tR, //bitsToNotRead
				m = (0xff >> (8 - tR)) << bN; //mask
			r = (z.bytes[z.byteOffset] & m) >> bN;
			nB -= tR;
			z.bitOffset += tR;
			if (z.bitOffset === 8) {
				z.bitOffset = 0;
				z.byteOffset++;
			}
		}
		if (nB > 0) {
			while (nB >= 8) {
				r = (r << 8) | (z.bytes[z.byteOffset] & 0xff); // Next read whole bytes
				z.byteOffset++;
				nB -= 8;
			}
			if (nB > 0) {
				const bN = 8 - nB, //bitsToNotRead // Finally read a partial byte
					m = (0xff >> bN) << bN; //mask
				r = (r << nB) | ((z.bytes[z.byteOffset] & m) >> bN);
				z.bitOffset += nB;
			}
		}
		return r;
	}
	a() {
		return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;
	}
}
/* 6 DecodeData*/
// StructuredAppend = 0x3,// FNC1FirstPosition = 0x5,// FNC1SecondPosition = 0x9,
class DD {
	static M = { Numeric: 'numeric', Alphanumeric: 'alphanumeric', Byte: 'byte', Kanji: 'kanji', ECI: 'eci' }; //Mode
	static B = {
		Terminator: 0,
		0: 'Terminator',
		Numeric: 1,
		1: 'Numeric',
		Alphanumeric: 2,
		2: 'Alphanumeric',
		Byte: 4,
		4: 'Byte',
		Kanji: 8,
		8: 'Kanji',
		ECI: 7,
		7: 'ECI',
	}; //ModeByte
	static dN(m, z) {
		const b = [], //(strm, size)//bytes
			cCS = [10, 12, 14][z]; //characterCountSize
		let t = '',
			l = m.r(cCS);
		while (l >= 3) {
			const n = m.r(10); // num// Read digits in groups of 3
			if (n >= 1000) W.e('Invalid numeric value above 999');
			const a = Math.floor(n / 100),
				b = Math.floor(n / 10) % 10,
				c = n % 10;
			b.push(48 + a, 48 + b, 48 + c);
			t += a.toString() + b.toString() + c.toString();
			l -= 3;
		}
		if (l === 2) {
			const n = m.r(7); // num// If the number of digits aren't a multiple of 3, the remaining digits are special cased.
			if (n >= 100) W.e('Invalid numeric value above 99');
			const a = Math.floor(n / 10),
				b = n % 10;
			b.push(48 + a, 48 + b);
			t += a.toString() + b.toString();
		} else if (l === 1) {
			const n = m.r(4); // num
			if (n >= 10) W.e('Invalid numeric value above 9');
			b.push(48 + n);
			t += n.toString();
		}
		return { bytes: b, text: t };
	}
	static ACC = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:'.split(''); //AlphanumericCharacterCodes
	static dA(m, z) {
		const b = [], //(strm, size)//bytes
			cCS = [9, 11, 13][z], //characterCountSize
			ACC = DD.ACC;
		let t = '',
			l = m.r(cCS);
		while (l >= 2) {
			const v = m.r(11),
				a = Math.floor(v / 45),
				b = v % 45;
			b.push(ACC[a].charCodeAt(0), ACC[b].charCodeAt(0));
			t += ACC[a] + ACC[b];
			l -= 2;
		}
		if (l === 1) {
			const a = m.r(6);
			b.push(ACC[a].charCodeAt(0));
			t += ACC[a];
		}
		return { bytes: b, text: t };
	}
	static dB(m, z) {
		const b = [], //(strm, size)//bytes
			cCS = [8, 16, 16][z]; //characterCountSize
		let t = '',
			l = m.r(cCS);
		for (let i = 0; i < l; i++) b.push(m.r(8));
		const a = b.map((b) => '%' + ('0' + b.toString(16)).substr(-2)).join('');
		try {
			t += decodeURIComponent(a);
		} catch (e) {
			console.log('decodeByte e:', e, b, a); // failed to decode
		}
		return { bytes: b, text: t };
	}
	static dK(m, z) {
		const b = [], //(strm, size)//bytes
			cCS = [8, 10, 12][z]; //characterCountSize
		let t = '',
			l = m.r(cCS);
		for (let i = 0; i < l; i++) {
			const k = m.r(13);
			let c = (Math.floor(k / 0xc0) << 8) | k % 0xc0;
			c += c < 0x1f00 ? 0x8140 : 0xc140;
			b.push(c >> 8, c & 0xff);
			t += String.fromCharCode(shiftJISTable[c]);
		}
		return { bytes: b, text: t };
	}
	static dec(d, v) {
		const s = new BS(d), //decode(data, ver) stream
			size = v <= 9 ? 0 : v <= 26 ? 1 : 2, // There are 3 'sizes' based on the version. 1-9 is small (0), 10-26 is medium (1) and 27-40 is large (2).
			chunks = [],
			bytes = [],
			r = {
				text: '', //result
				bytes,
				chunks,
				version: v,
			},
			M = DD.M,
			B = DD.B;
		while (s.a() >= 4) {
			const m = s.r(4); //mode
			if (m === B.Terminator) return r;
			else if (m === B.ECI) {
				if (s.r(1) === 0)
					chunks.push({
						type: M.ECI,
						assignmentNumber: s.r(7),
					});
				else if (s.r(1) === 0)
					chunks.push({
						type: M.ECI,
						assignmentNumber: s.r(14),
					});
				else if (s.r(1) === 0)
					chunks.push({
						type: M.ECI,
						assignmentNumber: s.r(21),
					});
				else
					chunks.push({
						type: M.ECI,
						assignmentNumber: -1,
					}); // ECI data seems corrupted
			} else if (m === B.Numeric) {
				const nr = DD.dN(s, size);
				r.text += nr.text;
				W.cat(bytes, nr.bytes);
				chunks.push({
					type: M.Numeric,
					text: nr.text,
				});
			} else if (m === B.Alphanumeric) {
				const ar = DD.dA(s, size);
				r.text += ar.text;
				W.cat(bytes, ar.bytes);
				chunks.push({
					type: M.Alphanumeric,
					text: ar.text,
				});
			} else if (m === B.Byte) {
				const br = DD.dB(s, size);
				r.text += br.text;
				W.cat(bytes, br.bytes);
				chunks.push({
					type: M.Byte,
					bytes: br.bytes,
					text: br.text,
				});
			} else if (m === B.Kanji) {
				const kr = DD.dK(s, size);
				r.text += kr.text;
				W.cat(bytes, kr.bytes);
				chunks.push({
					type: M.Kanji,
					bytes: kr.bytes,
					text: kr.text,
				});
			}
		}
		if (s.a() === 0 || s.r(s.a()) === 0) return r; // If there is no data left, or the remaining bits are all 0, then that counts as a termination marker
	}
}
/* 5 Decoder*/
class DC {
	static n(x, y) {
		let z = x ^ y; //numBitsDiffering
		let c = 0; //bitCount
		while (z) {
			c++;
			z &= z - 1;
		}
		return c;
	}
	static p = (bit, byte) => (byte << 1) | bit; //pushBit
	static F = [
		{ bits: 0x5412, formatInfo: { errorCorrectionLevel: 1, dataMask: 0 } }, //FORMAT_INFO_TABLE
		{ bits: 0x5125, formatInfo: { errorCorrectionLevel: 1, dataMask: 1 } },
		{ bits: 0x5e7c, formatInfo: { errorCorrectionLevel: 1, dataMask: 2 } },
		{ bits: 0x5b4b, formatInfo: { errorCorrectionLevel: 1, dataMask: 3 } },
		{ bits: 0x45f9, formatInfo: { errorCorrectionLevel: 1, dataMask: 4 } },
		{ bits: 0x40ce, formatInfo: { errorCorrectionLevel: 1, dataMask: 5 } },
		{ bits: 0x4f97, formatInfo: { errorCorrectionLevel: 1, dataMask: 6 } },
		{ bits: 0x4aa0, formatInfo: { errorCorrectionLevel: 1, dataMask: 7 } },
		{ bits: 0x77c4, formatInfo: { errorCorrectionLevel: 0, dataMask: 0 } },
		{ bits: 0x72f3, formatInfo: { errorCorrectionLevel: 0, dataMask: 1 } },
		{ bits: 0x7daa, formatInfo: { errorCorrectionLevel: 0, dataMask: 2 } },
		{ bits: 0x789d, formatInfo: { errorCorrectionLevel: 0, dataMask: 3 } },
		{ bits: 0x662f, formatInfo: { errorCorrectionLevel: 0, dataMask: 4 } },
		{ bits: 0x6318, formatInfo: { errorCorrectionLevel: 0, dataMask: 5 } },
		{ bits: 0x6c41, formatInfo: { errorCorrectionLevel: 0, dataMask: 6 } },
		{ bits: 0x6976, formatInfo: { errorCorrectionLevel: 0, dataMask: 7 } },
		{ bits: 0x1689, formatInfo: { errorCorrectionLevel: 3, dataMask: 0 } },
		{ bits: 0x13be, formatInfo: { errorCorrectionLevel: 3, dataMask: 1 } },
		{ bits: 0x1ce7, formatInfo: { errorCorrectionLevel: 3, dataMask: 2 } },
		{ bits: 0x19d0, formatInfo: { errorCorrectionLevel: 3, dataMask: 3 } },
		{ bits: 0x0762, formatInfo: { errorCorrectionLevel: 3, dataMask: 4 } },
		{ bits: 0x0255, formatInfo: { errorCorrectionLevel: 3, dataMask: 5 } },
		{ bits: 0x0d0c, formatInfo: { errorCorrectionLevel: 3, dataMask: 6 } },
		{ bits: 0x083b, formatInfo: { errorCorrectionLevel: 3, dataMask: 7 } },
		{ bits: 0x355f, formatInfo: { errorCorrectionLevel: 2, dataMask: 0 } },
		{ bits: 0x3068, formatInfo: { errorCorrectionLevel: 2, dataMask: 1 } },
		{ bits: 0x3f31, formatInfo: { errorCorrectionLevel: 2, dataMask: 2 } },
		{ bits: 0x3a06, formatInfo: { errorCorrectionLevel: 2, dataMask: 3 } },
		{ bits: 0x24b4, formatInfo: { errorCorrectionLevel: 2, dataMask: 4 } },
		{ bits: 0x2183, formatInfo: { errorCorrectionLevel: 2, dataMask: 5 } },
		{ bits: 0x2eda, formatInfo: { errorCorrectionLevel: 2, dataMask: 6 } },
		{ bits: 0x2bed, formatInfo: { errorCorrectionLevel: 2, dataMask: 7 } },
	];
	static M = [
		(p) => (p.y + p.x) % 2 === 0, //DATA_MASKS
		(p) => p.y % 2 === 0,
		(p) => p.x % 3 === 0,
		(p) => (p.y + p.x) % 3 === 0,
		(p) => (Math.floor(p.y / 2) + Math.floor(p.x / 3)) % 2 === 0,
		(p) => ((p.x * p.y) % 2) + ((p.x * p.y) % 3) === 0,
		(p) => (((p.y * p.x) % 2) + ((p.y * p.x) % 3)) % 2 === 0,
		(p) => (((p.y + p.x) % 2) + ((p.y * p.x) % 3)) % 2 === 0,
	];
	static m(v) {
		const d = 17 + 4 * v.versionNumber, //buildFunctionPatternMask//version //dimension
			m = BM.c(d, d); //matrix
		m.sR(0, 0, 9, 9, true); // Top left finder pattern + separator + format
		m.sR(d - 8, 0, 8, 9, true); // Top right finder pattern + separator + format
		m.sR(0, d - 8, 9, 8, true); // Bottom left finder pattern + separator + format
		for (const x of v.alignmentPatternCenters)
			for (const y of v.alignmentPatternCenters)
				if (!((x === 6 && y === 6) || (x === 6 && y === d - 7) || (x === d - 7 && y === 6)))
					m.sR(x - 2, y - 2, 5, 5, true); // Alignment patterns
		m.sR(6, 9, 1, d - 17, true); // Vertical timing pattern
		m.sR(9, 6, d - 17, 1, true); // Horizontal timing pattern
		if (v.versionNumber > 6) {
			m.sR(d - 11, 0, 3, 6, true); // Version info, top right
			m.sR(0, d - 11, 6, 3, true); // Version info, bottom left
		}
		return m;
	}
	static c(m, v, f) {
		const M = DC.M[f.dataMask], //readCodewords(mtx, ver, formatInfo)
			d = m.height, //dimension
			fPM = DC.m(v), //functionPatternMask
			c = []; //codewords
		let cb = 0, //currentByte
			b = 0, //bitsRead
			rU = true; //readingUp // Read columns in pairs, from right to left
		for (let cIdx = d - 1; cIdx > 0; cIdx -= 2) {
			if (cIdx === 6) cIdx--; // Skip whole column with vertical alignment pattern;
			for (let i = 0; i < d; i++) {
				const y = rU ? d - 1 - i : i;
				for (let cOff = 0; cOff < 2; cOff++) {
					const x = cIdx - cOff;
					if (!fPM.get(x, y)) {
						b++;
						let bit = m.get(x, y);
						if (M({ y: y, x: x })) bit = !bit;
						cb = DC.p(bit, cb);
						if (b === 8) {
							c.push(cb); // Whole bytes
							b = 0;
							cb = 0;
						}
					}
				}
			}
			rU = !rU;
		}
		return c;
	}
	static v(m) {
		const d = m.height, //readVersion(mtx)//dimension
			pV = Math.floor((d - 17) / 4); //provisionalVersion
		if (pV <= 6) return W.VERSIONS[pV - 1]; // 6 and under dont have version info in the QR code
		let tR = 0, //topRightVersionBits
			bL = 0; //bottomLeftVersionBits
		for (let y = 5; y >= 0; y--) for (let x = d - 9; x >= d - 11; x--) tR = DC.p(m.get(x, y), tR);
		for (let x = 5; x >= 0; x--) for (let y = d - 9; y >= d - 11; y--) bL = DC.p(m.get(x, y), bL);
		let bD = Infinity, //bestDifference
			bV = null; //bestVersion
		for (const v of W.VERSIONS) {
			if (v.infoBits === tR || v.infoBits === bL) return v;
			const d1 = DC.n(tR, v.infoBits),
				d2 = DC.n(bL, v.infoBits);
			if (d1 < bD) {
				bV = v;
				bD = d1;
			}
			if (d2 < bD) {
				bV = v;
				bD = d2;
			}
		}
		// We can tolerate up to 3 bits of error since no two version info codewords will
		// differ in less than 8 bits.
		return bD <= 3 ? bV : W.n('readVersion bD:' + bD);
	}
	static f(m) {
		let tL = 0, //readFormatInformation(mtx)//topLeftFormatInfoBits
			tR = 0; //topRightBottomRightFormatInfoBits
		for (let x = 0; x <= 8; x++) if (x !== 6) tL = DC.p(m.get(x, 8), tL); // Skip timing pattern bit
		for (let y = 7; y >= 0; y--) if (y !== 6) tL = DC.p(m.get(8, y), tL); // Skip timing pattern bit
		const d = m.height; //dimension
		for (let y = d - 1; y >= d - 7; y--) tR = DC.p(m.get(8, y), tR); // bottom left
		for (let x = d - 8; x < d; x++) tR = DC.p(m.get(x, 8), tR); // top right
		let bD = Infinity, //bestDifference
			bFI = null; //bestFormatInfo
		for (const a of DC.F) {
			const b = a.bits, //bits
				fI = a.formatInfo; //formatInfo
			if (b === tL || b === tR) return fI;
			const difl = DC.n(tL, b); //difference1
			if (difl < bD) {
				bFI = fI;
				bD = difl;
			}
			if (tL !== tR) {
				const dif = DC.n(tR, b); //difference// also try the other option
				if (dif < bD) {
					bFI = fI;
					bD = dif;
				}
			}
		}
		return bD <= 3 ? bFI : W.n('readFormatInformation bD:' + bD); // Hamming distance of the 32 masked codes is 7, by construction, so <= 3 bits differing means we found a match
	}
	static b(c, v, e) {
		const ei = v.errorCorrectionLevels[e], //getDataBlocks(codeWs, ver, ecLevel)//ecInfo
			db = []; //dataBlocks
		let tc = 0; //totalCodewords
		for (const b of ei.ecBlocks)
			for (let i = 0; i < b.numBlocks; i++) {
				db.push({ nD: b.dataCodewordsPerBlock, cw: [] });
				tc += b.dataCodewordsPerBlock + ei.ecCodewordsPerBlock;
			}
		// In some cases the QR code will be malformed enough that we pull off more or less than we should.
		// If we pull off less there's nothing we can do.
		// If we pull off more we can safely truncate
		if (c.length < tc) return W.n('getDataBlocks codeWs.length < tc:' + tc + '/codeWs:' + c.length);
		c = c.slice(0, tc);
		const s = ei.ecBlocks[0].dataCodewordsPerBlock; //shortBlockSize
		for (let i = 0; i < s; i++) for (const d of db) d.cw.push(c.shift()); // Pull codewords to fill the blocks up to the minimum size
		if (ei.ecBlocks.length > 1) {
			const sBC = ei.ecBlocks[0].numBlocks, //smallBlockCount// If there are any large blocks, pull codewords to fill the last element of those
				lBC = ei.ecBlocks[1].numBlocks; //largeBlockCount
			for (let i = 0; i < lBC; i++) db[sBC + i].cw.push(c.shift());
		}
		while (c.length > 0) for (const d of db) d.cw.push(c.shift()); // Add the rest of the codewords to the blocks. These are the error correction codewords.
		return db;
	}
	static x(m) {
		const v = DC.v(m); //decodeMatrix(mtx)//version
		if (!v) return W.n('decodeMatrix v', v);
		const fI = DC.f(m); //formatInfo
		if (!fI) return W.n('decodeMatrix fI', fI);
		const c = DC.c(m, v, fI), //codewords
			d = DC.b(c, v, fI.errorCorrectionLevel); //dataBlocks
		if (!d) return W.n('decodeMatrix d', d);
		const t = d.reduce((a, b) => a + b.nD, 0), //totalBytes// Count total number of data bytes
			r = W.u8ca(t); //resultBytes
		let ri = 0; //resultIndex
		for (const b of d) {
			const cb = RS.dec(b.cw, b.cw.length - b.nD); //correctedBytes
			if (!cb) return W.n('decodeMatrix cb', cb);
			for (let i = 0; i < b.nD; i++) r[ri++] = cb[i];
		}
		try {
			return DD.dec(r, v.versionNumber);
		} catch (e) {
			return W.n('decodeMatrix e', e);
		}
	}
	static dec(m) {
		if (m == null) return W.n('decode mtx:' + m); //decode(mtx)
		const r = DC.x(m);
		if (r) return r;
		for (let x = 0; x < m.width; x++)
			for (let y = x + 1; y < m.height; y++)
				if (m.get(x, y) !== m.get(y, x)) {
					m.set(x, y, !m.get(x, y)); // Decoding didn't work, try mirroring the QR across the topLeft -> bottomRight line.
					m.set(y, x, !m.get(y, x));
				}
		return DC.x(m);
	}
}
/* 11 Extractor*/
class EX {
	static s2Q(p1, p2, p3, p4) {
		const x3 = p1.x - p2.x + p3.x - p4.x, //squareToQuadrilateral
			y3 = p1.y - p2.y + p3.y - p4.y;
		if (x3 === 0 && y3 === 0)
			return {
				a11: p2.x - p1.x, // Affine
				a12: p2.y - p1.y,
				a13: 0,
				a21: p3.x - p2.x,
				a22: p3.y - p2.y,
				a23: 0,
				a31: p1.x,
				a32: p1.y,
				a33: 1,
			};
		else {
			const x1 = p2.x - p3.x,
				x2 = p4.x - p3.x,
				y1 = p2.y - p3.y,
				y2 = p4.y - p3.y,
				d = x1 * y2 - x2 * y1, //denominator
				a13 = (x3 * y2 - x2 * y3) / d,
				a23 = (x1 * y3 - x3 * y1) / d;
			return {
				a11: p2.x - p1.x + a13 * p2.x,
				a12: p2.y - p1.y + a13 * p2.y,
				a13: a13,
				a21: p4.x - p1.x + a23 * p4.x,
				a22: p4.y - p1.y + a23 * p4.y,
				a23: a23,
				a31: p1.x,
				a32: p1.y,
				a33: 1,
			};
		}
	}
	static q2S(p1, p2, p3, p4) {
		const s = EX.s2Q(p1, p2, p3, p4); //quadrilateralToSquare// Here, the adjoint serves as the inverse:
		return {
			a11: s.a22 * s.a33 - s.a23 * s.a32,
			a12: s.a13 * s.a32 - s.a12 * s.a33,
			a13: s.a12 * s.a23 - s.a13 * s.a22,
			a21: s.a23 * s.a31 - s.a21 * s.a33,
			a22: s.a11 * s.a33 - s.a13 * s.a31,
			a23: s.a13 * s.a21 - s.a11 * s.a23,
			a31: s.a21 * s.a32 - s.a22 * s.a31,
			a32: s.a12 * s.a31 - s.a11 * s.a32,
			a33: s.a11 * s.a22 - s.a12 * s.a21,
		};
	}
	static t(a, b) {
		return {
			a11: a.a11 * b.a11 + a.a21 * b.a12 + a.a31 * b.a13, //times
			a12: a.a12 * b.a11 + a.a22 * b.a12 + a.a32 * b.a13,
			a13: a.a13 * b.a11 + a.a23 * b.a12 + a.a33 * b.a13,
			a21: a.a11 * b.a21 + a.a21 * b.a22 + a.a31 * b.a23,
			a22: a.a12 * b.a21 + a.a22 * b.a22 + a.a32 * b.a23,
			a23: a.a13 * b.a21 + a.a23 * b.a22 + a.a33 * b.a23,
			a31: a.a11 * b.a31 + a.a21 * b.a32 + a.a31 * b.a33,
			a32: a.a12 * b.a31 + a.a22 * b.a32 + a.a32 * b.a33,
			a33: a.a13 * b.a31 + a.a23 * b.a32 + a.a33 * b.a33,
		};
	}
	static e(i, l) {
		const q = EX.q2S(
				{ x: 3.5, y: 3.5 }, //extract(img, loc
				{ x: l.dimension - 3.5, y: 3.5 },
				{ x: l.dimension - 6.5, y: l.dimension - 6.5 },
				{ x: 3.5, y: l.dimension - 3.5 }
			),
			s = EX.s2Q(l.topLeft, l.topRight, l.alignmentPattern, l.bottomLeft),
			t = EX.t(s, q), //transform
			m = BM.c(l.dimension, l.dimension), //matrix
			mF = (x, y) => {
				const d = t.a13 * x + t.a23 * y + t.a33; //mappingFunction//denominator
				return {
					x: (t.a11 * x + t.a21 * y + t.a31) / d,
					y: (t.a12 * x + t.a22 * y + t.a32) / d,
				};
			};
		for (let y = 0; y < l.dimension; y++)
			for (let x = 0; x < l.dimension; x++) {
				const sP = mF(x + 0.5, y + 0.5); //sourcePixel
				m.set(x, y, i.get(Math.floor(sP.x), Math.floor(sP.y)));
			}
		return {
			matrix: m,
			mappingFunction: mF,
		};
	}
}
/* 12 Locator*/
class LC {
	static MF = 4; //MAX_FINDERPATTERNS_TO_SEARCH
	static IQ = 0.5; //MIN_QUAD_RATIO
	static XQ = 1.5; //MAX_QUAD_RATIO
	static d = (a, b) => Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2)); //distance
	static s = (vals) => vals.reduce((a, b) => a + b); //sum
	// Takes three finder patterns and organizes them into topLeft, topRight, etc
	static rFP(p1, p2, p3) {
		const d12 = LC.d(p1, p2), //reorderFinderPatterns //oneTwoDistance // Find distances between pattern centers
			d23 = LC.d(p2, p3), //twoThreeDistance // Assume one closest to other two is B; A and C will just be guesses at first
			d13 = LC.d(p1, p3), //oneThreeDistance
			i = d23 >= d12 && d23 >= d13 ? [p2, p1, p3] : d13 >= d23 && d13 >= d12 ? [p1, p2, p3] : [p1, p3, p2];
		const tL = i[1]; //topLeft
		let bL = i[0], //bottomLeft
			tR = i[2]; //topRight
		// Use cross product to figure out whether bottomLeft (A) and topRight (C) are correct or flipped in relation to topLeft (B)
		// This asks whether BC x BA has a positive z component, which is the arrangement we want. If it's negative, then
		// we've got it flipped around and should swap topRight and bottomLeft.
		if ((tR.x - tL.x) * (bL.y - tL.y) - (tR.y - tL.y) * (bL.x - tL.x) < 0) {
			const j = [tR, bL];
			bL = j[0];
			tR = j[1];
		}
		return { bottomLeft: bL, topLeft: tL, topRight: tR };
	}
	static cD(tL, tR, bL, m) {
		const mS = //computeDimension(topLeft, topRight, bottomLeft, mtx)//moduleSize// Computes the dimension (number of modules on a side) of the QR Code based on the position of the finder patterns
			(LC.s(LC.cB(tL, bL, m, 5)) / 7 + // Divide by 7 since the ratio is 1:1:3:1:1
				LC.s(LC.cB(tL, tR, m, 5)) / 7 +
				LC.s(LC.cB(bL, tL, m, 5)) / 7 +
				LC.s(LC.cB(tR, tL, m, 5)) / 7) /
			4;
		if (mS < 1) W.e('Invalid module size');
		const tD = Math.round(LC.d(tL, tR) / mS), //topDimension
			sD = Math.round(LC.d(tL, bL) / mS), //sideDimension
			d = Math.floor((tD + sD) / 2) + 7; //dimension
		return { dimension: d + (!(d % 4) ? 1 : d % 4 === 2 ? -1 : 0), moduleSize: mS };
	}
	// Takes an origin point and an end point and counts the sizes of the black white run from the origin towards the end point.
	// Returns an array of elements, representing the pixel size of the black white run.
	// Uses a variant of http://en.wikipedia.org/wiki/Bresenham's_line_algorithm
	static cBT(o, e, m, l) {
		const M = Math, //countBlackWhiteRunTowardsPoint(org, end, mtx, len)
			sps = [{ x: M.floor(o.x), y: M.floor(o.y) }], //switchPoints
			st = M.abs(e.y - o.y) > M.abs(e.x - o.x), //steep
			fX = M.floor(st ? o.y : o.x),
			fY = M.floor(st ? o.x : o.y),
			tX = M.floor(st ? e.y : e.x),
			tY = M.floor(st ? e.x : e.y),
			dx = M.abs(tX - fX),
			dy = M.abs(tY - fY),
			xS = fX < tX ? 1 : -1,
			yS = fY < tY ? 1 : -1;
		let r = M.floor(-dx / 2), //error
			cP = true; //currentPixel // Loop up until x == toX, but not beyond
		for (let x = fX, y = fY; x !== tX + xS; x += xS) {
			// Does current pixel mean we have moved white to black or vice versa?
			// Scanning black in state 0,2 and white in state 1, so if we find the wrong
			// color, advance to next state or end if we are in state 2 already
			const rX = st ? y : x;
			const rY = st ? x : y;
			if (m.get(rX, rY) !== cP) {
				cP = !cP;
				sps.push({ x: rX, y: rY });
				if (sps.length === l + 1) break;
			}
			r += dy;
			if (r > 0) {
				if (y === tY) break;
				y += yS;
				r -= dx;
			}
		}
		const ds = []; //distances
		for (let i = 0; i < l; i++) ds.push(sps[i] && sps[i + 1] ? LC.d(sps[i], sps[i + 1]) : 0);
		return ds;
	}
	// Takes an origin point and an end point and counts the sizes of the black white run in the origin point
	// along the line that intersects with the end point. Returns an array of elements, representing the pixel sizes
	// of the black white run. Takes a length which represents the number of switches from black to white to look for.
	static cB(o, e, m, l) {
		const rise = e.y - o.y, //countBlackWhiteRun(org, end, mtx, len)
			run = e.x - o.x,
			tE = LC.cBT(o, e, m, Math.ceil(l / 2)), //towardsEnd
			aE = LC.cBT(
				o,
				{ x: o.x - run, y: o.y - rise },
				m, //awayFromEnd
				Math.ceil(l / 2)
			),
			mV = tE.shift() + aE.shift() - 1; //middleValue // Substract one so we don't double count a pixel
		let i;
		return (i = aE.concat(mV)).concat.apply(i, tE);
	}
	// Takes in a black white run and an array of expected ratios. Returns the average size of the run as well as the "error" -
	// that is the amount the run diverges from the expected ratio
	static sB(s, r) {
		const aS = LC.s(s) / LC.s(r); //scoreBlackWhiteRun(seq, ratios) //averageSize
		let e = 0; //error
		r.forEach((ratio, i) => {
			e += Math.pow(s[i] - ratio * aS, 2);
		});
		return { averageSize: aS, error: e };
	}
	// Takes an X,Y point and an array of sizes and scores the point against those ratios.
	// For example for a finder pattern takes the ratio list of 1:1:3:1:1 and checks horizontal, vertical and diagonal ratios
	// against that.
	static sP(p, r, m) {
		try {
			const hR = LC.cB(p, { x: -1, y: p.y }, m, r.length), //scorePattern(p, ratios, mtx)//horizontalRun
				vR = LC.cB(p, { x: p.x, y: -1 }, m, r.length), //verticalRun
				M = Math,
				tLP = {
					x: M.max(0, p.x - p.y) - 1,
					y: M.max(0, p.y - p.x) - 1,
				}, //topLeftPoint
				tL = LC.cB(p, tLP, m, r.length), //topLeftBottomRightRun
				bLR = {
					x: M.min(m.width, p.x + p.y) + 1,
					y: M.min(m.height, p.y + p.x) + 1,
				}, //bottomLeftPoint
				bL = LC.cB(p, bLR, m, r.length), //bottomLeftTopRightRun
				hE = LC.sB(hR, r), //horzError
				vE = LC.sB(vR, r), //vertError
				dD = LC.sB(tL, r), //diagDownError
				dU = LC.sB(bL, r), //diagUpError
				rE = M.sqrt(hE.error * hE.error + vE.error * vE.error + dD.error * dD.error + dU.error * dU.error), //ratioError
				aS = (hE.averageSize + vE.averageSize + dD.averageSize + dU.averageSize) / 4, //avgSize
				sE =
					(M.pow(hE.averageSize - aS, 2) +
						M.pow(vE.averageSize - aS, 2) +
						M.pow(dD.averageSize - aS, 2) +
						M.pow(dU.averageSize - aS, 2)) /
					aS; //sizeError
			return rE + sE;
		} catch (e) {
			console.log('scorePattern', e);
			return Infinity;
		}
	}
	static rL(m, p) {
		const M = Math; //recenterLocation(mtx, p)
		let lX = M.round(p.x);
		while (m.get(lX, M.round(p.y))) lX--;
		let rX = M.round(p.x);
		while (m.get(rX, M.round(p.y))) rX++;
		const x = (lX + rX) / 2;
		let tY = M.round(p.y);
		while (m.get(M.round(x), tY)) tY--;
		let bY = M.round(p.y);
		while (m.get(M.round(x), bY)) bY++;
		const y = (tY + bY) / 2;
		return { x, y };
	}
	static l(m) {
		let aFPQ = [], //locate(mtx) //activeFinderPatternQuads
			aAPQ = []; //activeAlignmentPatternQuads
		const fPQ = [], //finderPatternQuads
			aPQ = [], //alignmentPatternQuads
			M = Math,
			l1 = (y) => {
				let l1 = 0, //length_1
					lb = false, //lastBit
					ss = [0, 0, 0, 0, 0], //scans
					l2 = (x) => {
						const v = m.get(x, y);
						if (v === lb) l1++;
						else {
							ss = [ss[1], ss[2], ss[3], ss[4], l1];
							l1 = 1;
							lb = v;
							// Do the last 5 color changes ~ match the expected ratio for a finder pattern? 1:1:3:1:1 of b:w:b:w:b
							const aFPB = LC.s(ss) / 7, //averageFinderPatternBlocksize
								vFP = //validFinderPattern
									M.abs(ss[0] - aFPB) < aFPB &&
									M.abs(ss[1] - aFPB) < aFPB &&
									M.abs(ss[2] - 3 * aFPB) < 3 * aFPB &&
									M.abs(ss[3] - aFPB) < aFPB &&
									M.abs(ss[4] - aFPB) < aFPB &&
									!v, // And make sure the current pixel is white since finder patterns are bordered in white
								// Do the last 3 color changes ~ match the expected ratio for an alignment pattern? 1:1:1 of w:b:w
								aAPB = LC.s(ss.slice(-3)) / 3, //averageAlignmentPatternBlocksize
								vAP = //validAlignmentPattern
									M.abs(ss[2] - aAPB) < aAPB &&
									M.abs(ss[3] - aAPB) < aAPB &&
									M.abs(ss[4] - aAPB) < aAPB &&
									v; // Is the current pixel black since alignment patterns are bordered in black
							if (vFP) {
								// Compute the start and end x values of the large center black square
								const eX = x - ss[3] - ss[4], //endX_1
									sX = eX - ss[2], //startX_1
									line = { startX: sX, endX: eX, y: y },
									// Is there a quad directly above the current spot? If so, extend it with the new line. Otherwise, create a new quad with
									// that line as the starting point.//matchingQuads
									mQ = aFPQ.filter(
										(q) =>
											(sX >= q.bottom.startX && sX <= q.bottom.endX) ||
											(eX >= q.bottom.startX && sX <= q.bottom.endX) ||
											(sX <= q.bottom.startX &&
												eX >= q.bottom.endX &&
												ss[2] / (q.bottom.endX - q.bottom.startX) < LC.XQ &&
												ss[2] / (q.bottom.endX - q.bottom.startX) > LC.IQ)
									);
								if (mQ.length > 0) mQ[0].bottom = line;
								else aFPQ.push({ top: line, bottom: line });
							}
							if (vAP) {
								const eX = x - ss[4], //endX_2// Compute the start and end x values of the center black square
									sX = eX - ss[3], //startX_2
									line = { startX: sX, y, endX: eX },
									// Is there a quad directly above the current spot? If so, extend it with the new line. Otherwise, create a new quad with
									// that line as the starting point.//matchingQuads
									mQ = aAPQ.filter(
										(q) =>
											(sX >= q.bottom.startX && sX <= q.bottom.endX) ||
											(eX >= q.bottom.startX && sX <= q.bottom.endX) ||
											(sX <= q.bottom.startX &&
												eX >= q.bottom.endX &&
												ss[2] / (q.bottom.endX - q.bottom.startX) < LC.XQ &&
												ss[2] / (q.bottom.endX - q.bottom.startX) > LC.IQ)
									);
								if (mQ.length > 0) mQ[0].bottom = line;
								else aAPQ.push({ top: line, bottom: line });
							}
						}
					};
				for (let x = -1; x <= m.width; x++) l2(x);
				W.cat(
					fPQ,
					aFPQ.filter((q) => q.bottom.y !== y && q.bottom.y - q.top.y >= 2)
				);
				aFPQ = aFPQ.filter((q) => q.bottom.y === y);
				W.cat(
					aPQ,
					aAPQ.filter((q) => q.bottom.y !== y)
				);
				aAPQ = aAPQ.filter((q) => q.bottom.y === y);
			};
		for (let y = 0; y <= m.height; y++) l1(y);
		W.cat(
			fPQ,
			aFPQ.filter((q) => q.bottom.y - q.top.y >= 2)
		);
		W.cat(aPQ, aAPQ);
		const fPG = fPQ //finderPatternGroups
			.filter((q) => q.bottom.y - q.top.y >= 2) // All quads must be at least 2px tall since the center square is larger than a block
			.map((q) => {
				const x = (q.top.startX + q.top.endX + q.bottom.startX + q.bottom.endX) / 4,
					y = (q.top.y + q.bottom.y + 1) / 2;
				if (!m.get(M.round(x), M.round(y))) return;
				const l = [q.top.endX - q.top.startX, q.bottom.endX - q.bottom.startX, q.bottom.y - q.top.y + 1], //lengths
					size = LC.s(l) / l.length,
					score = LC.sP({ x: M.round(x), y: M.round(y) }, [1, 1, 3, 1, 1], m);
				return { score, x, y, size };
			})
			.filter((q) => !!q) // Filter out any rejected quads from above
			.sort((a, b) => a.score - b.score)
			.map((t, i, f) => {
				if (i > LC.MF) return null; //(point, i, finderPatterns) // Now take the top finder pattern options and try to find 2 other options with a similar size.
				const oP = f //otherPoints
					.filter((p, ii) => i !== ii)
					.map((p) => {
						return {
							x: p.x,
							y: p.y,
							score: p.score + M.pow(p.s - t.s, 2) / t.s,
							size: p.s,
						};
					})
					.sort((a, b) => a.score - b.score);
				return oP.length < 2
					? null
					: { points: [t].concat(oP.slice(0, 2)), score: t.score + oP[0].score + oP[1].score };
			})
			.filter((q) => !!q) // Filter out any rejected finder patterns from above
			.sort((a, b) => a.score - b.score);
		if (fPG.length === 0) return null;
		const i = LC.rFP(fPG[0].points[0], fPG[0].points[1], fPG[0].points[2]),
			tR = i.topRight, //topRight
			tL = i.topLeft, //topLeft
			bL = i.bottomLeft, //bottomLeft
			al = LC.fAP(m, aPQ, tR, tL, bL), //alignment
			r = []; //result
		if (al)
			r.push({
				alignmentPattern: { x: al.alignmentPattern.x, y: al.alignmentPattern.y },
				bottomLeft: { x: bL.x, y: bL.y },
				dimension: al.dimension,
				topLeft: { x: tL.x, y: tL.y },
				topRight: { x: tR.x, y: tR.y },
			});
		// We normally use the center of the quads as the location of the tracking points, which is optimal for most cases and will account
		// for a skew in the image. However, In some cases, a slight skew might not be real and instead be caused by image compression
		// errors and/or low resolution. For those cases, we'd be better off centering the point exactly in the middle of the black area. We
		// compute and return the location data for the naively centered points as it is little additional work and allows for multiple
		// attempts at decoding harder images.
		const mTR = LC.rL(m, tR), //midTopRight
			mTL = LC.rL(m, tL), //midTopLeft
			mBL = LC.rL(m, bL), //midBottomLeft
			cAl = LC.fAP(m, aPQ, mTR, mTL, mBL); //centeredAlignment
		if (cAl)
			r.push({
				alignmentPattern: {
					x: cAl.alignmentPattern.x,
					y: cAl.alignmentPattern.y,
				},
				bottomLeft: { x: mBL.x, y: mBL.y },
				topLeft: { x: mTL.x, y: mTL.y },
				topRight: { x: mTR.x, y: mTR.y },
				dimension: cAl.dimension,
			});
		return r.length === 0 ? null : r;
	}
	static fAP(m, a, tR, tL, bL) {
		//findAlignmentPattern(mtx, alignmentPatternQuads, topRight, topLeft, bottomLeft)// Now that we've found the three finder patterns we can determine the blockSize and the size of the QR code.
		let d, s; // We'll use these to help find the alignment pattern but also later when we do the extraction.
		try {
			const i = LC.cD(tL, tR, bL, m);
			d = i.dimension;
			s = i.moduleSize;
		} catch (e) {
			return W.n('findAlignmentPattern e:', e);
		}
		const bRFP = {
				x: tR.x - tL.x + bL.x, // Now find the alignment pattern
				y: tR.y - tL.y + bL.y,
			}, //bottomRightFinderPattern
			mBFP = (LC.d(tL, bL) + LC.d(tL, tR)) / 2 / s, //modulesBetweenFinderPatterns
			c2TL = 1 - 3 / mBFP, //correctionToTopLeft
			eAP = {
				x: tL.x + c2TL * (bRFP.x - tL.x),
				y: tL.y + c2TL * (bRFP.y - tL.y),
			}; //expectedAlignmentPattern
		let aps = a
			.map((q) => {
				const x = (q.top.startX + q.top.endX + q.bottom.startX + q.bottom.endX) / 4,
					y = (q.top.y + q.bottom.y + 1) / 2,
					M = Math;
				if (!m.get(M.floor(x), M.floor(y))) return;
				const ss = LC.sP({ x: M.floor(x), y: M.floor(y) }, [1, 1, 1], m); //sizeScore
				return { x, y, score: ss + LC.d({ x: x, y: y }, eAP) };
			})
			.filter((v) => !!v)
			.sort((a, b) => a.score - b.score);
		// If there are less than 15 modules between finder patterns it's a version 1 QR code and as such has no alignmemnt pattern
		// so we can only use our best guess.
		return { alignmentPattern: mBFP >= 15 && aps.length ? aps[0] : eAP, dimension: d };
	}
}
/* 3 */
class JsQR {
	static s(mtx) {
		const ls = LC.l(mtx); //scan//locations
		if (!ls) return W.n('scan A ls:' + ls);
		for (const l of ls) {
			const ex = EX.e(mtx, l), //extracted
				dc = DC.dec(ex.matrix); //decoded
			if (dc)
				return {
					binaryData: dc.bytes,
					data: dc.text,
					chunks: dc.chunks,
					version: dc.version,
					location: {
						topRightCorner: ex.mappingFunction(l.dimension, 0),
						topLeftCorner: ex.mappingFunction(0, 0),
						bottomRightCorner: ex.mappingFunction(l.dimension, l.dimension),
						bottomLeftCorner: ex.mappingFunction(0, l.dimension),
						topRightFinderPattern: l.topRight,
						topLeftFinderPattern: l.topLeft,
						bottomLeftFinderPattern: l.bottomLeft,
						bottomRightAlignmentPattern: l.alignmentPattern,
					},
				};
		}
		return W.n('scan B ls:' + ls);
	}
	static async exec(data, width, height, providedOptions = {}) {
		await W.init();
		const o = {
			inversionAttempts: 'attemptBoth', //defaultOptions.inversionAttempts
		};
		for (const k in o) o[k] = providedOptions[k] || o[k];
		const i = o.inversionAttempts,
			s = i === 'attemptBoth' || i === 'invertFirst', //shouldInvert
			t = i === 'onlyInvert' || i === 'invertFirst', //tryInvertedFirst
			j = BZ.bz(data, width, height, s),
			r = JsQR.s(t ? j.inverted : j.binarized);
		return !r && (i === 'attemptBoth' || i === 'invertFirst') ? JsQR.s(t ? j.binarized : j.inverted) : r;
	}
}
export const jsQR = JsQR.exec;
